1. Объектно-ориентированная методология. Абстрагирование.

	Объектно-ориентированное программирование - это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса.
Классы образуют иерархию наследования.

	Объектно-ориентированная методология (ООМ) ориентирована, прежде всего, на создание больших систем, коллективную их разработку, последующее активное сопровождение при эксплуатации и регулярные модификации.

	Абстрагирование – выделение существенных характеристик некоторого объекта, которые отличают его от всех других видов объектов и четко определяют его концептуальные границы с точки зрения дальнейшего рассмотрения и анализа

	Абстракция в объектно-ориентированном программировании — это существенные характеристики объекта, которые отличают его от всех других объектов, четко определяя его концептуальные границы. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому, как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более примитивных функций (Данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня).

	Такой подход является основой объектно-ориентированного программирования. Это позволяет работать с объектами, не вдаваясь в особенности их реализации. В каждом конкретном случае применяется тот или иной подход: инкапсуляция, полиморфизм или наследование. Например, при необходимости обратиться к скрытым данным объекта, следует воспользоваться инкапсуляцией, создав, так называемую, функцию доступа или свойство.
	
2.Объектно-ориентированная методология. Инкапсуляция.

	Инкапсуляция – объединение данных (атрибутов) и поведения (операций) в рамках класса

	Инкапсуляция — свойство языка программирования, позволяющее объединить данные и код в объект и скрыть реализацию объекта от пользователя (прикладного программиста). При этом пользователю предоставляется только спецификация (интерфейс) объекта. Пользователь может взаимодействовать с объектом только через этот интерфейс. Реализуется с помощью директив: public, private, protected.

	Инкапсуляция — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с абстракцией, полиморфизмом и наследованием).

	Предостережение: Одна из наиболее распространенных ошибок — делать сокрытие реализации только ради сокрытия. Целями, достойными усилий, являются:

	- предельная локализация изменений при необходимости таких изменений,

	- прогнозируемость изменений (какие изменения в коде надо сделать для заданного изменения функциональности) и прогнозируемость последствий изменений.

3. Объектно-ориентированная методология. Иерархичность.

	Иерархия - ранжированная или упорядоченная система абстракций.

	Принцип иерархичности предполагает использование иерархических структур при разработке программных систем.

	Основными видами иерархических структур применительно к сложным системам являются иерархии типа «является» и иерархии типа «имеет».

	Иерархия «является» подразумевает, что элемент, стоящий на нижнем уровне абстракции, является разновидностью (частным случаем) элемента, стоящего на верхнем уровне.
	
	Важный элемент объектно-ориентированных систем и основной вид иерархии «является» - иерархия наследования (отношение родитель-потомок).

	Наследование означает такое отношение между абстракциями, когда абстракция-потомок заимствует структурную и/или функциональную часть одной или нескольких абстракций-родителей. Если абстракция-потомок заимствует часть одной абстракции-родителя, то говорят об одиночном наследовании. Если же потомок заимствует части нескольких родителей, то говорят о множественном наследовании. Часто потомок достраивает или переписывает компоненты родителя.

4. Объектно-ориентированная методология. Модульность.

	Модульность – свойство системы, связанное с возможностью ее декомпозиции на ряд внутренне связных, но слабо связанных между собой модулей.
	
	Модульность – система состоит из независимых компонент – модулей, для которых определены программные интерфейсы их взаимодействие, а сами они построены по принципу «черного ящика» - их внутреннее содержание скрыто от внешнего пользователя;

	Модульность — в языках программирования — принцип, согласно которому программное средство (ПС, программа, библиотека, web-приложение и др.) разделяется на отдельные именованные сущности, называемые модулями. Модульность часто является средством упрощения задачи проектирования ПС и распределения процесса разработки ПС между группами разработчиков. При разбиении ПС на модули для каждого модуля указывается реализуемая им функциональность, а также связи с другими модулями.

	Связанность - характеристика взаимосвязи модуля с другими модулями.

Связность - характеристика внутренней взаимосвязи между частями одного модуля.

5. Объектно-ориентированная методология. Полиморфизм.

	Полиморфизм — одна из трех основных парадигм ООП. Если говорить кратко, полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового. 

	Полиморфизм позволяет писать более абстрактные программы и повысить коэффициент повторного использования кода. Общие свойства объектов объединяются в систему, которую могут называть по-разному — интерфейс, класс. Общность имеет внешнее и внутреннее выражение. Внешне общность проявляется как одинаковый набор методов с одинаковыми именами и сигнатурами (именем методов и типами аргументов). Внутренняя общность есть одинаковая функциональность методов. Её можно описать интуитивно или выразить в виде строгих законов, правил, которым должны подчиняться методы. Возможность приписывать разную функциональность одному методу (функции, операции) называется перегрузкой метода (функций, операций).

	Полиформизм позволяет вызовом переопределённого метода через переменную класса-родителя получить поведение, которое будет соответствовать реальному классу-потомку, на который ссылается эта переменная.

6. Типы данных. Совместимость типов данных. Преобразование типов данных. Полиморфность типов. Абстрактный тип данных.
	
	ТИПЫ
	
	Тип данных — класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены.
	Тип данных — категоризация абстрактного множества возможных значений, характеристик и набор операций для некоторого атрибута.
	Типы могут делиться на 
	- скалярные (простые):
		- порядковые (целые, символьные, логические);
		- вещественные;
	- составные:
		- массивы;
		- строки;
		- файловые типы;
		- множества;
		- объекты;
		- классы;
	- ссылочные;
	- процедурные;

	СОВМЕСТИМОСТЬ

	Вобщем случае при выполнении арифметических (и любых других) операций компилятору требуется, чтобы типы операндов совпадали: нельзя, например, сложить массив и множество, нельзя передать вещественное число функции, ожидающей целый аргумент, и т.п.

	В то же время, любая процедура или функция, написанная в расчете на вещественные значения, сможет работать и с целыми числами.

	Несколько "симптомов" совместимости типов данных:
	Два типа Т1 и Т2 совместимы в следующих случаях:
 		- Т1 и Т2 - один и тот же тип или они идентичны;
 		- Т1 и Т2 - вещественные типы;
 		- Т1 и Т2 - целые типы;
		- один тип является строкой, а другой - строкой или символом;

	СОВМЕСТИМОСТЬ ДЛЯ ПРИСВАИВАНИЯ:
		Эта совместимость необходима, когда значение какого-то выражения
присваивается переменной, типизированной константе, функции. 
	Если значение объекта 
типа Т2 присваивается объекту типа Т1, то это возможно в следующих случаях:
 		- Т1 и Т2 - идентичные типы и не являются файловыми типами или структурированными 
   типами, содержащими компоненты файлового типа на любом уровне структурирования;
 		- Т1 и Т2 - совместимые порядковые типы и значение типа Т2 находится в
   границах возможных значений объекта типа Т1;
 		- Т1 и Т2 - вещественные типы и значение типа Т2 находится в границах
   возможных значений объекта типа Т1;
 		- Т1 - вещественный тип, а Т2 - целый тип;
 		- Т1 и Т2 - строки;
 		- Т1 - строка, а Т2 - символ;

	ПРЕОБРАЗОВАНИЕ

	Преобразование (приведение) типа — в информатике преобразование значения одного типа в значение другого типа.

	Выделяют преобразования типов:

		- явные;
		- неявные; 
	
	Явное приведение задаётся программистом в тексте программы с помощью:

	- конструкции языка;
	- функции, принимающей значение одного типа и возвращающей значение другого типа.

	Неявное приведение выполняется транслятором (компилятором или интерпретатором) по правилам, описанным в стандарте языка. Стандарты большинства языков запрещают неявные преобразования.

	ПОЛИМОРФНОСТЬ

	АБСТРАКТНЫЙ ТИП ДАННЫХ
	
	В программировании абстрактные типы данных обычно представляются в виде интерфейсов, которые скрывают соответствующие реализации типов. Программисты работают с абстрактными типами данных исключительно через их интерфейсы, поскольку реализация может в будущем измениться. Такой подход соответствует принципу инкапсуляции в объектно-ориентированном программировании. Сильной стороной этой методики является именно сокрытие реализации. Раз вовне опубликован только интерфейс, то пока структура данных поддерживает этот интерфейс, все программы, работающие с заданной структурой абстрактным типом данных, будут продолжать работать. 
	
	Абстрактные типы данных позволяют достичь модульности программных продуктов и иметь несколько альтернативных взаимозаменяемых реализаций отдельного модуля.

7.Объявление классов в С++. Конструктор и деструктор, виды и правила объявления.

	Классы в С++ — это абстракция описывающая методы, свойства, ещё не существующих объектов. Объекты — конкретное представление абстракции, имеющее свои свойства и методы. Созданные объекты на основе одного класса называются экземплярами этого класса. 
	Объявление класса начинается с зарезервированного ключевого слова class, после  которого пишется имя класса.
	
	Конструктор — функция, предназначенная для инициализации объектов класса.
	ООП дает возможность программисту описать функцию, явно предназначенную для инициализации объектов. Поскольку такая функция конструирует значения данного типа, она называется конструктором. Конструктор всегда имеет то же имя, что и сам класс и никогда не имеет возвращаемого значения. Когда класс имеет конструктор, все объекты этого класса будут проинициализированы.
	Конструктор, не требующий параметров, называется конструктором по умолчанию.
	Определяемый пользователем класс имеет конструктор, который обеспечивает надлежащую инициализацию. Для многих типов также требуется обратное действие. Деструктор обеспечивает соответствующую очистку объектов указанного типа. Имя деструктора представляет собой имя класса с предшествующим ему знаком «тильда» ~. Так, для класса X деструктор будет иметь имя ~X(). Многие классы используют динамическую память, которая выделяется конструктором, а освобождается деструктором.

8. Объявление методов класса в С++. Модификаторы.

	Методы — это функции, которые могут выполнять какие-либо действия над данными (свойствами) класса.
	 Модификатор в языке С++ — это некое специальное слово, которое добавляется к методам, классам, переменным, функциям и и дает специальные «надстройки» основному компоненту.
	Все свойства и методы классов имеют права доступа. По умолчанию, все содержимое класса является доступным для чтения и записи только для него самого. Для того, чтобы разрешить доступ к данным класса извне, используют модификатор доступа public. Все функции и переменные, которые находятся после модификатора public, становятся доступными из всех частей программы.
	Закрытые данные класса размещаются после модификатора доступа private. Если отсутствует модификатор public, то все функции и переменные, по умолчанию являются закрытыми.
	Обычно, приватными делают все свойства класса, а публичными — его методы. Все действия с закрытыми свойствами класса реализуются через его методы.

9. Объявление наследования классов в С++. Таблица виртуальных функций. Множественное наследование. Абстрактный класс.

	В C ++ есть несколько типов наследования:

	- публичный (public)- публичные (public) и защищенные (protected) данные наследуются без изменения уровня доступа к ним;
	- защищенный (protected) — все унаследованные данные становятся защищенными;
	- приватный (private) — все унаследованные данные становятся приватными.

	Например, 
	class Device {
	/* определение методов */

	};
	class Computer: public Device {
	/* определение своих методов, но можем пользоваться всеми унаследованными методами Device */
	};

	Для реализации виртуальных функций C++ использует специальную форму позднего связывания, известную как виртуальная таблица. Виртуальная таблица – это таблица поиска функций, используемая для разрешения вызовов функций в режиме динамического/позднего связывания. Виртуальную таблицу иногда также называют «таблица виртуальных функций (методов)».
	
	Эта таблица представляет собой просто статический массив, который компилятор создает и заполняет во время компиляции. Виртуальная таблица содержит по одной записи для каждой виртуальной функции, которая может быть вызвана объектами класса. Каждая запись в этой таблице – это просто указатель на функцию, указывающий на наиболее производную версию функции, доступную для данного класса.
	
	Множественное наследование позволяет порожденному классу наследовать элементы более, чем от одного базового класса.
	Например,  
 	class X
	{...};
	class Y
	{...};
	class Z
	{...};
	class A : public X, public Y, public Z
	{...};
	А обобщённо наследует элементы всех трёх основных классов X,Y,Z.
	Проблемы могут возникнуть в следующих случаях:
	- если в порожденном классе используется член с таким же именем, как в одном из базовых классов;
	- когда в нескольких базовых классах определены члены с одинаковыми именами.

	Абстрактные классы - это классы, которые содержат или наследуют без переопределения хотя бы одну чистую виртуальную функцию. Абстрактный класс определяет интерфейс для переопределения производными классами.
	
	Что такое чистые виртуальные функции? Это функции, которые не имеют определения. Чтобы определить виртуальную функцию как чистую, ее объявление завершается значением "=0".
	class Figure {
	public: virtual double getSquare() = 0;
	};
	класс абстрактный, потому что имеет чистую виртуальную функцию, не имеющую реализации. Реализацию должны определять классы-наследники:
	...
	class Rectangle: public Figure {
	/* реализация функций */
	};

10. Управление памятью на уровне операционной системы. Кэш процессора. Виртуальная память.

	НУ ЭТО МЫ УЖЕ ЗНАЕМ :)))) 

11. Управление памятью на системном уровне. Структура программы в оперативной памяти.
	Оперативная память— это рабочая область для процессора компьютера. В ней во время работы хранятся программы и данные. Оперативная память часто рассматривается как временное хранилище, потому что данные и программы в ней сохраняются только при включенном компьютере.
	бля я хз

12. Управление памятью на прикладном уровне. Модель кучи.

	Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. 
	 По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.
	В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей.
	
13. Управление памятью на прикладном уровне. Сборщик мусора.
	
	Сборщик мусора - одна из форм автоматического управления памятью. Специальный процесс, называемый сборщиком мусора периодически освобождает память, удаляя из неё ставшие ненужными объекты. Это решает большинство проблем с утечками памяти, хотя и лишает возможности героически превознемогать ошибки сегментации.

	Сборщики мусора бывают двух видов — консервативные и копирующие.

	Автоматическая сборка мусора позволяет повысить безопасность доступа к памяти. 
	Если бы память компьютера была бесконечной, можно было бы просто оставлять ненужные объекты в памяти. Автоматическое управление памятью со сборкой мусора — эмуляция такого бесконечного компьютера на конечной памяти. Многие ограничения сборщиков мусора (нет гарантии, что финализатор выполнится; управляет только памятью, но не другими ресурсами) вытекают из этой метафоры.

14. Управление памятью средствами C++. Идиома RAII.
	RAII - расшифровывается как Resource Acquisition is Initialization - захват ресура и есть инициализация.
	Идиома очень простая и кратко описывается следующим образом: в конструкторе объект получает доступ к какому либо ресурсу (например, открывается файл или устанавливается соединение по сети к базе данных) и сохраняет описатель ресурса в закрытый члена класса, а при вызове деструктура этот ресурс освобождается (закрывается файл или соединение к БД). При объявлении объекта данного класса на стеке происходит и его инициализация с вызовом конструктора, захватывающий ресурс. При выходе из области видимости объект выталкивается из стека, но перед этим вызывается деструктор объекта, который и освобождает захваченный ресурс.
	Возможно, самое популярное использование RAII – это управление динамически выделяемой памятью с помощью умных указателей, но она также может с успехом применяться и к другим ресурсам, особенно в мире низкоуровневых библиотек. Примеры включают в себя дескрипторы Windows API, файловые дескрипторы POSIX, примитивы OpenGL и тому подобное.

15. Управление памятью средствами C++. Создание и уничтожение объектов. Объявления переменных, область видимости.
	Любому объекту требуется память и некоторое начальное значение. В C++ это обеспечивается с помощью объявлений, являющихся одновременно определениями. В большинстве случаев при обсуждении объявлений мы подразумеваем именно такие объявления.
	Например,
 
	void function() {
	int a=6;
	double b[5]={0.0};
	struct c {int i; double j; }
	}
	здесь все объекты создают при входе в блок при вызове function().	
	Конструктор (constructor) — это функция-член, имя которой совпадает с именем класса. Он создает значения типа своего класса.
	 Деструктор (destructor) — это функция-член, имя которой представляет собой имя класса, предваряемое символом - (тильда). Обычно деструктор предназначен для уничтожения значений типа класса, как правило, с помощью delete.
	
	Область видимости переменных — это те части программы, в которой пользователь может изменять или использовать переменные в своих нуждах.

	В C++ существуют отдельные блоки, которые начинаются с открывающей скобки ({) и заканчиваются соответственно закрывающей скобкой (}). Такими блоками являются циклы (for, while, do while) и функции.
	Если переменная была создана в таком блоке, то ее областью видимости будет являться этот блок от его начала (от открывающей скобки —  { ) и до его конца (до закрывающей скобки — } ) включая все дочерние блоки созданные в этом блоке.
	Глобальными переменными называются те переменные, которые были созданы вне тела какого-то блока. Их можно всегда использовать во всей вашей программе, вплоть до ее окончания работы, т.е. область видимости глобальных переменных - вся программа. 
	Локальные переменные — это переменные созданные в блоках. Областью видимости таких переменных является блоки ( и все их дочерние ), а также их область видимости не распространяется на другие блоки. Как ни как, но эти переменные созданы в отдельных блоках.
	Если мы создадим глобальную переменную и с таким же именем локальную, то получится, что там где была создана локальная переменная будет использоваться именно локальная переменная, а не глобальная. Так как локальная переменная считается по приоритету выше глобальной.

16. Ссылки в C++. Временные объекты. R-values.

	Ссылка (reference) представляет способ манипулировать каким-либо объектом. Фактически ссылка - это альтернативное имя для объекта. Для определения ссылки применяется знак амперсанда &.
	Например 
	double number = 1.0;
	double &refnumber = number;

	Определена ссылка refnumber, которая ссылается на объект number. При этом в определении ссылки используется тот же тип, который представляет объект, на который ссылка ссылается, то есть в данном случае int.	
	Основные правила ссылок на плюсах:
	- нельзя просто определить ссылку, она должна указывать на объект, т.е.
	double &refnumber - хуета
	- нельзя присвоить ссылочному типу число (double &refnumber = 6.66 - тоже говно)
	- можно определять ссылки на константы, но тогда ссылка тоже константа
	const int number = 1;
	const int &refnumber = number;
	по-другому - низя 

	Временные объекты — в программировании объекты, которые компилятор создаёт автоматически по ходу вычисления выражений. Такие объекты не имеют имени и уничтожаются сразу же, как только в них исчезает потребность.
	Временные объекты имеют время существования, определенное их точкой создания и точкой их уничтожения. Любое выражение, создающее несколько временных объектов, в конечном итоге уничтожает их в обратном порядке создания.
	
	Rvalue ссылки – маленькое техническое расширение языка C++. Они позволяют программистам избегать логически ненужного копирования и обеспечивать возможность идеальной передачи.
	
	Rvalue ссылка – это составной тип, очень похожий на традиционную ссылку в C++.

	Пример определения r-value ссылки:
	int number = 10;
	int&& refnumber = number;

	R-value ссылка ведет себя точно так же, как и традиционная ссылка, за исключением того, что она может быть связана с временным объектом, тогда как традиционную ссылку связать с временным (не константным) объектом нельзя.

17. Модульность. Способы реализации модульности в C++.

	Модульность – свойство системы, связанное с возможностью ее декомпозиции на ряд внутренне связных, но слабо связанных между собой модулей.
	
	Модульность – система состоит из независимых компонент – модулей, для которых определены программные интерфейсы их взаимодействие, а сами они построены по принципу «черного ящика» - их внутреннее содержание скрыто от внешнего пользователя;

	Модульность — в языках программирования — принцип, согласно которому программное средство (ПС, программа, библиотека, web-приложение и др.) разделяется на отдельные именованные сущности, называемые модулями. Модульность часто является средством упрощения задачи проектирования ПС и распределения процесса разработки ПС между группами разработчиков. При разбиении ПС на модули для каждого модуля указывается реализуемая им функциональность, а также связи с другими модулями.

	 В языке C++ модулями являются файлы, которые компилируются отдельно один от другого и затем объединяются в один исполняемый файл при помощи редактора связей.

	Интерфейс модуля экспортирует имя модуля и все пространства имен, типы, функции и т. д., составляющие открытый интерфейс модуля. Реализация модуля определяет элементы, экспортируемые модулем. В простейшей форме модуль может состоять из одного файла, объединяющего интерфейс модуля и реализацию. Реализации также можно поместить в один или несколько отдельных файлов реализации модуля, аналогично тому, как .h используются файлы и .cpp.

	Модуль состоит из одной или нескольких единиц модуля. Модуль — это единица перевода (исходный файл), содержащая объявление модуля. Существует несколько типов модулей:
	- модуль интерфейса модуля
	- единица реализации модуля
	- основная единица интерфейса модуля
	- единица интерфейса секции модуля
	- единица реализации секции модуля

18. Пространство имен в C++

	Пространство имен — это декларативная область, в рамках которой определяются различные идентификаторы (имена типов, функций, переменных, и т. д.). 

	Пространства имен используются для организации кода в виде логических групп и с целью избежания конфликтов имен, которые могут возникнуть, особенно в таких случаях, когда база кода включает несколько библиотек. Все идентификаторы в пределах пространства имен доступны друг другу без уточнения.

	Идентификаторы за пределами пространства имен могут получить доступ к членам с помощью полного имени для каждого идентификатора, например std::vector<std::string> vec;, с помощью объявления для одного идентификатора (using std::string) или директивы using для всех идентификаторов в пространстве имен (using namespace std;). Код в файлах заголовков всегда должен содержать полное имя в пространстве имен.

	Пространство имен может быть объявлено в нескольких блоках в одном файле и в нескольких файлах. Компилятор соединит вместе все части во время предварительной обработки и полученное в результате пространство имен будет содержать все члены, объявленные во всех частях. Примером этого является пространство имен std, которое объявляется в каждом из файлов заголовка в стандартной библиотеке.

19. Архитектура программных систем. Архитектурные шаблоны.

	В начале развития информационных технологий термин «архитектура» применялся только к аппаратному обеспечению (архитектура ЭВМ, вычислительных комплексов, сетей и др.) и лишь позже стал применяться к программному обеспечению.

	Говоря об архитектуре программных систем, прежде всего надо определить понятие «программная система». Распространено такое определение: «Программная система - это совокупность системных, прикладных и сервисных программ, обеспечивающих решение некоторой совокупности задач».

	Программные системы могут входить в состав программных комплексов. Обычно это более масштабные системы в рамках больших технических и организационных систем. Системы, в свою очередь, могут состоять из подсистем. Архитектурные решения необходимы на каждом из этих уровней.
	
	Архитектура программы или компьютерной системы - это структура или структуры системы, которые включают элементы программы, видимые извне свойства этих элементов и связи между ними.

	Основные идеологические определения архитектуры ПС таковы:

	1) архитектура ПС - это набор решений, наиболее существенным образом влияющих на совокупную стоимость владения системой;
	2) архитектура ПС - это набор ключевых решений, неизменных при изменении бизнес-технологии в рамках бизнес-видения.
	
	Архитектурные шаблоны. 

	Архитектурный шаблон — это обобщенное часто используемое решение распространенной задачи в архитектуре ПО в заданном контексте. Шаблон — это решение задачи в определенном контексте.

	Основные архитектурные шаблоны:
	1. Многоуровневый шаблон
	2. Клиент-серверный шаблон
	3. Ведущий-ведомый
	4. Каналы и фильтры

	Многоуровневый шаблон. 
	Данный шаблон используется для структурирования программ, которые можно разложить на группы неких подзадач, находящихся на определенных уровнях абстракции. Каждый слой предоставляет службы для следующего, более высокого слоя. 4 слоя:
	- слой представления (слой пользовательского интерфейса)
	- слой приложения (слой сервиса)
	- слой бизнес-логики
	- слой доступа к данным

Используется на общих десктопных приложениях и в веб-приложениях.

	Клиент-серверный шаблон.
	Данный шаблон состоит из двух частей: сервера и множества клиентов. Серверный компонент предоставляет службы клиентским компонентам. Клиенты запрашивают услуги у сервера, а он, в свою очередь, оказывает эти самые услуги клиентам. Более того, сервер продолжает «подслушивать» клиентские запросы.

	Используется в онлайн-приложениях (эл. почта, совместный доступ к документам, банковские услуги).

20. Принципы чистой архитектуры.	

	Чистая архитектура — это способ организации кода, который способствует строгому разделению ответственности. Приложение разбивается на независимые функциональные компоненты, которые взаимодействуют друг с другом определённым способом, при этом между ними передаются только те ресурсы, которые необходимы для выполнения поставленной задачи. Это помогает минимизировать сложность каждого компонента, снижает вероятность ошибок и ускоряет их устранение при выявлении.

	Плюсы:

- удобство тестирования
- независимость от фреймворка
- независимость от баз данных

	Минусы:
- нужно писать больше кода
- высокий порог входа

21. Умные указатели в STL. std::unique_ptr, std::move.

	Когда мы говорим про управление памятью в C++, мы неизменно обращаемся к термину storage duration (длительность хранения). Длительность хранения – это свойство объекта, которое описывает, когда тот попадает в память и когда её освобождает.
	Как правило, основной целью задействования умных указателей является инкапсуляция работы с динамической памятью таким образом, чтобы свойства и поведение умных указателей имитировали свойства и поведение обычных указателей. При этом на них возлагается обязанность своевременного и аккуратного высвобождения выделенных ресурсов, что упрощает разработку кода и процесс отладки, исключая утечки памяти и возникновение висячих ссылок.
	

	std::unique_ptr - ссылается на объект в динамической памяти и при выходе из области видимости уничтожает хранимый объект

	Когда std::unique_ptr выходит из области видимости, утечки памяти не происходит, потому что в своем деструкторе умный указатель вызывает delete для объекта на который ссылается, высвобождая тем самым память.

	std::unique_ptr используется тогда, когда объект должен иметь только одного владельца, однако мы можем передать право на владение кому-то другому. Чтобы это сделать, необходимо использовать std::move. 
	
22. Умные указатели в STL. std::shared_ptr, std::weak_ptr.

	std::shared_ptr разрешает объекту иметь несколько владельцев, а когда все владельцы уничтожаются, уничтожается и объект. Такое поведение достигается за счёт наличия специального счётчика ссылок внутри std::shared_ptr. Каждый раз, когда такой указатель копируется, счётчик инкрементируется, а когда один из указателей уничтожается – декрементируется. В момент, когда счётчик достигает нуля, объект уничтожается.
	
	Существуют ситуации, когда объект A должен ссылаться на B, а B – на A. Это называется циклической ссылкой. В таком случае оба объекта никогда не будут выгружены из памяти.
	
	Чтобы разорвать цикличность, необходимо использовать std::weak_ptr. Это фактически умный указатель non owning, предназначенный для использования именно с std::shared_ptr. Копирование std::weak_ptr не увеличивает счётчик в std::shared_ptr, а значит и не защищает объект от уничтожения. При этом всегда имеется возможность проверить, существует ли ещё объект, на который ссылается std::weak_ptr, или нет.

23. Основные алгоритмы в STL. Предикаты, функторы.

	Функторы
Функторы (их еще называют объект-функциями или функциональным объектном) - конструкция, которая предоставляет возможность использовать объект как функцию. Функциональный объект является экземпляром класса С++, в котором определён operator(). Если вы определите operator()для C++ класса, то вы получите объект, который действует как функция, но может также хранить состояние.
	
	Предикаты
Предикаты - подмножество функторов, в которых тип возвращаемого значения operator() bool. Смысл в том, что объект-функция в случае использования предиката возвращает истину или ложь в зависимости от выполнения необходимого условия. Это либо удовлетворение объектом неких свойств, либо результат сравнения двух объектов по определенному признаку.

	Основные алгоритмы в STL:

1. for_each(): выполнение действия для группы элементов (возможно всех) контейнера.

2. find(): это поиск некоторого элемента в коллекции.

24. Основные контейнеры в STL. std::vector, std::list.

	Вектор в C++ — это замена стандартному динамическому массиву, память для которого выделяется вручную, с помощью оператора new. Методы класса vector:
	- push_back() - добавление нового элемента в конец вектора
	- size() - количество элементов
	- pop_back() - удалить последний элемент
	- clear() - очистить вектор
	- empty() - проверка вектора на пустоту

	Контейнер list представляет двухсвязный список. Для его использования необходимо подключить заголовочный файл list. Методы класса list:
	- front()/back() - возвращение первого и последнего элемента
	- size() - размер списка
	- empty() - проверка на пустоту
	- resize(n) - оставляет в списке n первых элементов
	- resize(n, value) - то же самое, но если размер списка меньше n, то добавляются недостающее до n число элементов со значением value.
	- swap() - обменивает значениями два списка
	- push_back() - добавление нового элемента в конец
	- push_front() - добавление нового элемента в начало списка

25. Основные контейнеры в STL. std::map и std::set.

	map - это ассоциативный контейнер, который работает по принципу — [ключ — значение]. 
	Он схож по применению с вектором или массивом, но есть различия:
1) Ключом может быть что угодно (переменная, класс и т.д.)
2) При добавлении нового элемента контейнер отсортируется по возрастанию.

Пример словаря map:

map <string, string> mp;
mp["Привет"] = "Hello";

Итераторы необходимы при оперировании с контейнером map.  Создание итератора:
 map<тип данных> :: iterator <name>;
	чтобы обратиться к ключу используется name->first
	чтобы обратиться к значению ячейки name->second.

Методы map:
	- insert() - вставка нового элемента
	- count() - количество элементов с данным ключом!!!
	- find() - узнать, есть ли определённый ключ в контейнере
	- erase() - удалить элемент

 
	set - то контейнер, который автоматически сортирует добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, set будет хранить только один его экземпляр. По другому его еще называют множеством.
Создание: set <тип><имя>;

Методы: 
	- insert() - вставка нового элемента
	- copy() - используется много для чего, например вывод элементов контейнера
	пример использвоания: copy([начала], [конец], ostream_iterator <[тип]>(cout, [отступ]));

	- erase() - удалить конкретный элемент - <name>.erase([iterator])
		  - удалить все элементы с данным значением - <name>.erase([ключ])
	
	- lower_bound() - эта функция находит элемент который больше или равен ключу (>= key).
	
	- upper_bound() - ищет элемента, который строго больше ключа key.
	- find() - возвращает местонахождение клчюча - итератор

26. Основные контейнеры в STL. Понятие итератора.

	Итератор — это объект, который может перебирать элементы в контейнере стандартной библиотеки С++ и предоставлять доступ к отдельным элементам. Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.

	В стандартной библиотеке С++ началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом. Глобальные функции begin и возвращают итераторы end в указанный контейнер.

	Над итераторами можно совершать операции инкремента, декремента, сравнение двух итераторов.

27. Шаблонные классы и функции.
	
	Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа.

	Шаблон класса (class template) позволяет задать тип для объектов, используемых в классе.

	Для применения шаблонов перед классом указывается ключевое слово template, после которого идут угловые скобки. В угловых скобках после слова typename идет параметр шаблона. Можно определить несколько параметров шаблона

	Параметр шаблона представляет произвольный идентификатор, в качестве которого, как правило, применяюся заглавные буквы, например, T. Но это необязательно. То есть в данном случае параметр T будет представлять некоторый тип, который становится известным во время компиляции. Это может быть и тип int, и double, и string, и любой другой тип. И теперь идентификатор счета будет представлять тип, который передается через параметр T.

	Шаблоны классов работают аналогично шаблонам функций. Они не описывают готовые типы, это инструкции для порождения классов подстановкой значений шаблонных аргументов.

	Терминология для шаблонов классов аналогична рассмотренной для функций. Обобщённое описание называется шаблоном класса. После передачи типа в качестве шаблонного аргумента из шаблона класса порождается новый шаблонный класс. Во всех местах, где выполняется подстановка того же типа, будет подразумеваться один и тот же тип шаблонного класса.

28. Обработка ошибок. Исключения.
	
	В процессе работы программы могут возникать различные ошибки. Например, при передаче файла по сети оборвется сетевое подключение или будут введены некорректные и недопустимые данные, которые вызовут падение программы. Такие ошибки еще называются исключениями. Если исключение не обработано, то при его возникновении программа прекращает свою работу.

	Оператор throw генерирует исключение. Через оператор throw можно передать информацию об ошибке.

	Например:
	
	double divide(int a, int b)
{
    if (b == 0)
        throw "Division by zero!";
    return a / b;
}

	То есть если параметр b равен 0, то генерируем исключение.

	Но это исключение еще надо обработать в коде, где будет вызываться функция divide. Для обработки исключений применяется конструкция try...catch. Она имеет следующую форму:

	try
{
    инструкции, которые могут вызвать исключение
}
	catch(объявление_исключения)
{
    обработка исключения
}

	В блок после ключевого слова try помещается код, который потенциально может сгенерировать исключение.

	После ключевого слова catch в скобках идет параметр, который передает информацию об исключении. Затем в блоке производится собственно обработка исключения.

29. Лямбда функции. std::function.

	лямбда-выражение ( часто называемое лямбда-выражением) — это удобный способ определения анонимного объекта функции ( закрытия) в расположении, где он вызывается или передается в качестве аргумента функции. Как правило, лямбда-выражения используются для инкапсуляции нескольких строк кода, передаваемых алгоритмам или асинхронным функциям.

	Шаблон класса std :: function - это универсальный полиморфный функциональный пакет. Экземпляры std :: function могут сохранять, копировать и вызывать любые целевые сущности, которые могут быть вызваны. Эти целевые сущности включают обычные функции, лямбда-выражения, указатели на функции и другие функциональные объекты. Объект std :: function - это типобезопасный пакет для существующих вызываемых сущностей в C ++ (мы знаем, что вызываемые сущности, такие как указатели на функции, не являются типобезопасными).

	Обычно std :: function - это класс объекта функции, который является оболочкой для любого другого объекта функции.Обложенный объект функции имеет N параметров типа T1,…, TN и возвращает значение, которое может быть преобразовано в тип R. std :: function использует конструктор преобразования шаблона для получения обернутого объекта функции; в частности, тип закрытия может быть неявно преобразован в std :: function.

30. Асинхронность. Callbacks. Корутины.

лень.